xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}lines ( xtrace , ftrace , type=”b”,col=”blue”)
xs <− seq(0,4, len=20)
plot(xs, f(xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x−2)^2 +3.2))
### df/dx = 2.4(x−2)
### df/dx = 0 −−−> 0 = 2.4x − 4.8 −−−> x = 2
lines (c (2,2), c (3,8), col = "red", lty =2)
text (2.1,7, "Closed−form solution", col="red", pos=4)
### gradient descent
x <− 0.1
xtrace <− x
ftrace <− f(x)
stepFactor <− 0.6 ### try larger and smaller values (0.8 and 0.01)
for (step in 1:100) {
x <− x − stepFactor * grad(x)
xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}
lines ( xtrace , ftrace , type="b", col="blue")
text (0.5,6, "Gradient Descent",col=”blue”,pos=4)
xs <− seq(0,4, len=20)
plot(xs, f(xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x−2)^2 +3.2))
### df/dx = 2.4(x−2)
### df/dx = 0 −−−> 0 = 2.4x − 4.8 −−−> x = 2
lines (c (2,2), c (3,8), col = "red", lty =2)
text (2.1,7, "Closed−form solution", col="red", pos=4)
### gradient descent
x <− 0.1
xtrace <− x
ftrace <− f(x)
stepFactor <− 0.6 ### try larger and smaller values (0.8 and 0.01)
for (step in 1:100) {
x <− x − stepFactor * grad(x)
xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}
lines ( xtrace , ftrace , type="b", col="blue")
text (0.5,6, "Gradient Descent", col = "blue", pos=4)
source("./R/gradientDescents.R")
x <− 0.1
result <− steepest(x, f, grad , stepsize =0.6, nIterations =100, xtracep=TRUE, ftracep=TRUE)
plot (xs, f(xs ), type="l",xlab="x", ylab=expression(1.2(x−2)^2 +3.2))
lines ( result $xtrace , result $ ftrace , type="b",col="blue")
text (0.5,6, "Gradient Descent with steepest ()", col ="blue",pos=4)
source("./R/gradientDescents.R")
x <− 0.1
result <− steepest(x, f,
grad,
stepsize = 0.6,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot (xs, f(xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace , type ="b", col ="blue")
text (0.5,6, "Gradient Descent with steepest ()", col ="blue",pos=4)
plot(xs, f(xs ), type= "l", xlab="x", ylab=expression(1.2(x−2)^2 +3.2))
x <− 0.1
xtrace <− x
ftrace <− f(x)
for (step in 1:100) {
x <− x − grad(x)/secondGrad(x)
xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}
lines(xtrace, ftrace , type="b",col="blue")
text (0.5,6, "Newton's Gradient Descent",col="blue",pos=4)
source("./R/gradientDescents.R")
x <− 0.1
result <− scg(x, f,
grad ,
nIterations =100,
xtracep=TRUE,
ftracep=TRUE)
plot (xs , f (xs ), type="l",xlab="x",ylab=expression(1.2(x−2)^2 +3.2))
lines (result$xtrace, result$ftrace , type ="b", col="blue")
text (0.5,6, "Gradient Descent with scg ()", col ="blue",pos=4)
source("./R/gradientDescents.R")
x <− 0.1
result <− scg(x, f,
grad ,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot(xs, f (xs), type = "l", xlab = "x",ylab=expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace, type = "b", col = "blue")
text(0.5, 6, "Gradient Descent with scg ()", col = "blue", pos = 4)
plot(xs, f(xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
x <− 0.1
xtrace <− x
ftrace <− f(x)
for (step in 1:100) {
x <− x − grad(x) / secondGrad(x)
xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}
lines(xtrace, ftrace, type = "b", col = "blue")
text (0.5, 6, "Newton's Gradient Descent", col = "blue", pos = 4)
f <- function(x) {
1.2 * (x−2)^2 + 3.2
}
grad <− function(x) {
1.2 * 2 * (x−2)
}
secondGrad <− function(x) {
2.4
}
xs <− seq(0,4, len = 20)
plot(xs, f(xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x−2)^2 +3.2))
### df/dx = 2.4(x−2)
### df/dx = 0 −−−> 0 = 2.4x − 4.8 −−−> x = 2
lines (c(2,2), c(3,8), col = "red", lty = 2)
text (2.1, 7, "Closed−form solution", col = "red", pos = 4)
### gradient descent
x <− 0.1
xtrace <− x
ftrace <− f(x)
stepFactor <− 0.6 ### try larger and smaller values (0.8 and 0.01)
for (step in 1:100) {
x <− x − stepFactor * grad(x)
xtrace <− c(xtrace, x)
ftrace <− c(ftrace, f(x))
}
lines( xtrace , ftrace , type="b", col = "blue")
text(0.5, 6, "Gradient Descent", col = "blue", pos = 4)
source("./R/gradientDescents.R")
x <− 0.1
result <− steepest(x, f,
grad,
stepsize = 0.6,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot(xs, f(xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace , type = "b", col = "blue")
text (0.5, 6, "Gradient Descent with steepest ()", col = "blue", pos = 4)
source("./R/gradientDescents.R")
x <− 0.1
result <− scg(x, f,
grad,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot(xs, f (xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace, type = "b", col = "blue")
text(0.5, 6, "Gradient Descent with scg ()", col = "blue", pos = 4)
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
f <- function(x) {
1.2 * (x−2)^2 + 3.2
}
grad <− function(x) {
1.2 * 2 * (x−2)
}
secondGrad <− function(x) {
2.4
}
xs <− seq(0,4, len = 20)
plot(xs, f(xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x−2)^2 +3.2))
### df/dx = 2.4(x−2)
### df/dx = 0 −−−> 0 = 2.4x − 4.8 −−−> x = 2
lines (c(2,2), c(3,8), col = "red", lty = 2)
text (2.1, 7, "Closed−form solution", col = "red", pos = 4)
### gradient descent
x <− 0.1
xtrace <− x
ftrace <− f(x)
stepFactor <− 0.6 ### try larger and smaller values (0.8 and 0.01)
for (step in 1:100) {
x <− x − stepFactor * grad(x)
xtrace <− c(xtrace, x)
ftrace <− c(ftrace, f(x))
}
lines( xtrace , ftrace , type="b", col = "blue")
text(0.5, 6, "Gradient Descent", col = "blue", pos = 4)
source("./R/gradientDescents.R")
x <− 0.1
result <− steepest(x, f,
grad,
stepsize = 0.6,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot(xs, f(xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace , type = "b", col = "blue")
text(0.5, 6, "Gradient Descent with steepest ()", col = "blue", pos = 4)
plot(xs, f(xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
x <− 0.1
xtrace <− x
ftrace <− f(x)
for (step in 1:100) {
x <− x − grad(x) / secondGrad(x)
xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}
lines(xtrace, ftrace, type = "b", col = "blue")
text(0.5, 6, "Newton's Gradient Descent", col = "blue", pos = 4)
source("./R/gradientDescents.R")
x <− 0.1
result <− scg(x, f,
grad,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot(xs, f (xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace, type = "b", col = "blue")
text(0.5, 6, "Gradient Descent with scg ()", col = "blue", pos = 4)
install.packages("RcppOctave")
install.packages("RcppOctave")
install.packages("RcppOctave", source)
install.packages("RcppOctave", type="source")
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
install.packages(c("digest", "dygraphs", "fields", "ggplot2", "git2r", "Hmisc", "htmlTable", "jsonlite", "nycflights13", "openssl", "pracma", "psych", "RcppArmadillo", "rmarkdown", "rsconnect", "RSQLite", "selectr", "shiny", "sp", "tidyr", "xml2", "zoo"))
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
fx <- cxxfunction(signature(x = "numeric"), 'NumericVector xx(x);
return wrap(std::accumulate(xx.begin(), xx.end(), 0.0));'
, plugin = "Rcpp"
fx <- cxxfunction(signature(x = "numeric"), 'NumericVector xx(x);return wrap(std::accumulate(xx.begin(), xx.end(), 0.0));', plugin = "Rcpp"
library(Rcpp)
library(inline)
fx <- cxxfunction(signature(x = "numeric"), 'NumericVector xx(x);return wrap(std::accumulate(xx.begin(), xx.end(), 0.0));', plugin = "Rcpp")
fx <- cxxfunction(signature(x = "numeric"), 'NumericVector xx(x); return wrap(std::accumulate(xx.begin(), xx.end(), 0.0));', plugin = "Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
sessionInfo()
View(y)
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
x <- leukemia[, 1:38]   #: take only the first 38 columns
n <- nrow(x)      # number of rows
p <- ncol(x)      # number of columns
y <- matrix(0, n, p)
for (i in 1:n) {
sig <- sd(x[i, ])
mu <- mean(x[i, ])
y[i, ] <- (x[i, ] - mu) / sig
}
library(R.matlab)
# Set knitr options for knitting code into the report:
# - Don't print out code (echo)
# - Save results so that code blocks aren't re-run unless code changes (cache),
# _or_ a relevant earlier code block changed (autodep), but don't re-run if the
# only thing that changed was the comments (cache.comments)
# - Don't clutter R output with messages or warnings (message, warning)
# This _will_ leave error messages showing up in the knitted report
knitr::opts_chunk$set(echo = TRUE,
cache = TRUE,
autodep = TRUE,
cache.comments = FALSE,
message = FALSE,
warning = FALSE,
error = TRUE,
comment = NA)
library(RcppOctave)
.CallOctave("version")
.CallOctave("sqrt", 10)
.CallOctave("eye", 3)
.CallOctave("eye", 3, 2)
install.packages("RcppOctave")
library(Rcpp)
sourceCpp("../../src/MatrixExample.cpp")
M <- matrix((1:16)^2, 4)
class(M)
ME <- MatrixExample(M)
class(ME)
ME
library(Rcpp)
myroot <- cppFunction('double myroot(double x) { return ::sqrt(x); }')
myroot(16)
library(Rcpp)               ## recent version for sourceCpp()
sourceCpp("../../src/eigenEx.cpp")    ## converts source file into getEigen() we can call
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
library(Rcpp)
install.packages("Rcpp")
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
library(Rcpp)
library(Rcpp)
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
library(Rcpp)
fibR <- function(n){
## I commented this out because I am not handling errors in the C++ code,
## so the code is comparable
# if (n < 0) {
#  stop("Argument n must be non-negative integer.\n")
# } else
if (n == 0) {
return(0)
} else if (n == 1) {
return(1)
} else {
Recall(n-1) + Recall(n-2)
}
}
n <- 10:26
time.to.calculate <- sapply(n, function(x) system.time(fibR(x))[3])
plot(n, time.to.calculate, xlab="n", ylab="seconds",
main="Fibonacci F calculation time", type="b")
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
library(Rcpp)
library(Rcpp)
library(inline)
install.packages("inline")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
fun(matrix(1,4,4))
library(Rcpp)
myroot <- cppFunction('double myroot(double x) { return ::sqrt(x); }')
myroot(16)
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
library(Rcpp)
fibR <- function(n){
## I commented this out because I am not handling errors in the C++ code,
## so the code is comparable
# if (n < 0) {
#  stop("Argument n must be non-negative integer.\n")
# } else
if (n == 0) {
return(0)
} else if (n == 1) {
return(1)
} else {
Recall(n-1) + Recall(n-2)
}
}
n <- 10:26
time.to.calculate <- sapply(n, function(x) system.time(fibR(x))[3])
plot(n, time.to.calculate, xlab="n", ylab="seconds",
main="Fibonacci F calculation time", type="b")
PKG_CXXFLAGS=`Rscript -e 'Rcpp:::CxxFlags()'` \
PKG_LIBS=`Rscript -e 'Rcpp:::LdFlags()'`  \
R CMD SHLIB fibWrap.cpp
library(Rcpp)
dyn.load("fibWrap.so")
.Call("fibWrapper", 5) # Evaluates fibWrapper() at 5
.Call("fibWrapper", 9)
.Call("fibWrapper", 10)
library(Rcpp)
sourceCpp("../../src/fibBest.cpp")
n2 <- 10:(26+12) # Some extra 12 values
time.to.calculateCpp <- sapply(n2, function(x) system.time(fibCpp(x))[3])
plot(n2, c(time.to.calculate, rep(NA,12)), xlab="n", ylab="seconds",
main="Fibonacci F calculation time", type="b")
lines(n2, time.to.calculateCpp, type="b", col="Red")
legend("topleft", inset=0.01, legend=c("R","C++"), pch=1, col=1:2)
#include <Rcpp.h>
#include <cmath>        // std::exp(double)
#include <valarray>     // std::valarray, std::exp(valarray)
using namespace Rcpp;
// [[Rcpp::export]]
NumericVector dnormCpp(NumericVector x, double mu, double sigma) {
// const double MYPI = 3.141592;
// I think PI is available in cmath
int n = x.size();
NumericVector d(n);
NumericVector ret(n);
for(int i = 0; i < n; i++){
d[i] = (x[i] - mu)/sigma;
d[i] *= d[i];
ret[i] = exp(-0.5*d[i])/(sqrt(2*PI)*sigma);
}
return(ret);
}
require(RcppEigen)
sourceCpp("../../src/xtSx.cpp")
S <- matrix(c(1,.5,.5,1),ncol=2)
Y <- c(3,2)
X <- matrix(c(1,0,1,1), ncol=2)
solve(t(X)%*%solve(S)%*%X)%*%t(X)%*%solve(S)%*%Y
xtSx(X,S,Y)
sourceCpp("../../src/xtSxMod.cpp")
timeCppFast <- numeric(length(n))
k <- 0
set.seed(1)
for(i in n){
k <- k + 1
Y <- rnorm(i)
X <- matrix(rnorm(i*p), ncol=p)
S <- matrix(0, i, i)
for(j in 1:i){
S[j,] = 0.5^abs(j - 1:i)
}
timeCppFast[k] <- system.time(xtSxMod(X,S,Y))[3]
}
