end
")
N <- 50000
set.seed(42)
x1 <- c(.O$orngg(9,1,N))
x2 <- c(.O$orngg(4,1,N))
x3 <- c(.O$orngg(1,1,N))
set.seed(42)  # reset RNG
y1 <- rgamma(N,9,1)
y2 <- rgamma(N,4,1)
y3 <- rgamma(N,1,1)
#NOTE: RcppOctave's Octave function randg already has a scale parameter:
set.seed(42)
z1 <- c(.O$randg(9,N,1,1))
z2 <- c(.O$randg(4,N,1,1))
z3 <- c(.O$randg(1,N,1,4))
stopifnot(all.equal(x1,z1))
stopifnot(all.equal(x2,z2))
stopifnot(all.equal(x3,z3))
## define a Gamma RNG draw function
o_source(text="
function x = orngg(a, b, n)
x = b * randg(a, n, 1);
end
")
N <- 50000
set.seed(42)
x1 <- c(.O$orngg(9,1,N))
x2 <- c(.O$orngg(4,1,N))
x3 <- c(.O$orngg(1,1,N))
set.seed(42)  # reset RNG
y1 <- rgamma(N,9,1)
y2 <- rgamma(N,4,1)
y3 <- rgamma(N,1,1)
#NOTE: RcppOctave's Octave function randg already has a scale parameter:
set.seed(42)
z1 <- c(.O$randg(9,N,1,1))
z2 <- c(.O$randg(4,N,1,1))
z3 <- c(.O$randg(1,N,1,1))
stopifnot(all.equal(x1,z1))
stopifnot(all.equal(x2,z2))
stopifnot(all.equal(x3,z3))
# see also wrapper function ?o_rgamma, that is more similar to the other o_* RNG functions
# in term of parameter order.
stopifnot(all.equal(x1,y1))
stopifnot(all.equal(x2,y2))
stopifnot(all.equal(x3,y3))
op <- par(mfcol=c(2,1), lwd=2, mar=c(4,3,3,1))
plot(density(x1), main="Calling randg from Octave",
col="orange", ylim=c(0,0.23), xlim=c(-1,22))
lines(density(x2), col='mediumblue')
lines(density(x3), col='brown')
plot(density(y1), main="Calling rgamma from R",
col="orange", ylim=c(0,0.23), xlim=c(-1,22))
lines(density(y2), col='mediumblue')
lines(density(y3), col='brown')
par(op)
op <- par(mfcol=c(2,1), lwd=2, mar=c(4,3,3,1))
plot(density(x1), main="Calling randg from Octave",
col="orange", ylim=c(0,0.23), xlim=c(-1,22))
lines(density(x2), col='mediumblue')
lines(density(x3), col='brown')
plot(density(y1), main="Calling rgamma from R",
col="orange", ylim=c(0,0.23), xlim=c(-1,22))
lines(density(y2), col='mediumblue')
lines(density(y3), col='brown')
par(op)
require(rbenchmark)
require(compiler)
require(RcppOctave)
## define a Gamma RNG draw function
o_source(text="
function x = orngg(a, b, n)
x = b * randg(a, n, 1);
end
")
N <- 50000
set.seed(42)
x1 <- c(.O$orngg(9,1,N))
x2 <- c(.O$orngg(4,1,N))
x3 <- c(.O$orngg(1,1,N))
set.seed(42)  # reset RNG
y1 <- rgamma(N,9,1)
y2 <- rgamma(N,4,1)
y3 <- rgamma(N,1,1)
#NOTE: RcppOctave's Octave function randg already has a scale parameter:
set.seed(42)
z1 <- c(.O$randg(9,N,1,1))
z2 <- c(.O$randg(4,N,1,1))
z3 <- c(.O$randg(1,N,1,1))
stopifnot(all.equal(x1,z1))
stopifnot(all.equal(x2,z2))
stopifnot(all.equal(x3,z3))
# see also wrapper function ?o_rgamma, that is more similar to the other o_* RNG functions
# in term of parameter order.
stopifnot(all.equal(x1,y1))
stopifnot(all.equal(x2,y2))
stopifnot(all.equal(x3,y3))
op <- par(mfcol=c(2,1), lwd=2, mar=c(4,3,3,1))
plot(density(x1), main="Calling randg from Octave",
col="orange", ylim=c(0,0.23), xlim=c(-1,22))
lines(density(x2), col='mediumblue')
lines(density(x3), col='brown')
plot(density(y1), main="Calling rgamma from R",
col="orange", ylim=c(0,0.23), xlim=c(-1,22))
lines(density(y2), col='mediumblue')
lines(density(y3), col='brown')
par(op)
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
library(R.matlab)
leukemia.mat <- readMat("../data/leukemia.mat", fixNames = TRUE)
class(leukemia.mat)
install.packages("R.matlab")
library(R.matlab)
leukemia.mat <- readMat("../data/leukemia.mat", fixNames = TRUE)
class(leukemia.mat)
names(leukemia.mat)
leukemia <- leukemia.mat$leukemia
x <- leukemia[, 1:38]   #: take only the first 38 columns
n <- nrow(x)      # number of rows
p <- ncol(x)      # number of columns
y <- matrix(0, n, p)
for (i in 1:n) {
sig <- sd(x[i, ])
mu <- mean(x[i, ])
y[i, ] <- (x[i, ] - mu) / sig
}
image(y,
col = grey(seq(0, 1, length = 256)),
main = 'Gene Expression for Leukemia',
xlab = "ALL (1-27) or AML (28-38)",
ylab = "Gene"
)
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
library(R.matlab)
# read the Matlab array
software.mat <- readMat("../data/software.mat", fixNames = TRUE)
names(software.mat)
prepsloc <- software.mat$prepsloc
defsloc  <- software.mat$defsloc
plot(prepsloc, defsloc)
# first data transformation
X = log(prepsloc)
Y = log(defsloc)
# plot the transformed data
plot(X, Y,
xlab = "Log PrepTime/SLOC",
ylab = "Log Defects/SLOC"
)
n <- 100
mu <- c(-2, 2)
sigma <- matrix(c(1, 0.5, 0.5, 1), nrow = 2)
n
mu
sigma
library(MASS)
set.seed(123)
head(X)
X <- mvrnorm(n, mu, sigma)
#plot(X[, 1], X[, 2])
source("../R/matlab.R")
# read the matrix from Matlab table
x_table <- read.csv('table.csv', header = FALSE)
# convert to matrix
X <- as.matrix(x_table)
xbar <- colMeans(X)   # calculate the means of the columns
# get the eigenvectors and eigenvalues of the covariance matrix
eig <- mlab_eig(cov(X))  # calculate the eigenVv of the covariance of X
D <- eig$D
V <- eig$V
# center the data
Xc <- X - matrix(1, n, 1) %*% xbar
# Sphere the data
z <- D %^% (-1/2) %*% t(V) %*% t(Xc)  # using a custom built ^ operator
Z <- t(z)                             # transpose to plot
plot(Z[, 1], Z[, 2])
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
# enter data as rows
X = matrix(c(4, 3, -4, 5), nrow=2, byrow = TRUE)
X
# get theta
theta <- pi /3
# obtain the projection matrix
c2 <- cos(theta)^2
cs <- cos(theta)*sin(theta)
s2 <- sin(theta)^2
P <- array(c(c2, cs, cs, s2), dim = c(2,2))
cat("Projection matrix at angle:\n")
P
# obtain the projection matrix
c2 <- cos(theta)^2
cs <- cos(theta)*sin(theta)
s2 <- sin(theta)^2
P <- array(c(c2, cs, cs, s2), dim = c(2,2))
cat("Projection matrix at angle:\n")
P
source("../R/matlab.R")
Xp <- X %*% P
Xp
Px <- matrix(c(1, 0), nrow=2)
Xpx <- X %*% Px
cat("Ortogonal projection:\n")
Px
cat("Projection over the x-axis\n")
Xpx
plot(X[, 1], X[, 2],
xlim = c(-8, 8),
ylim = c(-8, 8),
pch = 20,
cex = 1.55
)
projectionMatrixLine(P, col = 'green')   # draw the projection line at angle
abline(h=0, v=0)             # lines at (0, 0)
points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
library(R.matlab)
# read the Matlab array
yeast.mat <- readMat("../data/yeast.mat", fixNames = TRUE)
names(yeast.mat)
data <- yeast.mat$data
n <- nrow(data)
p <- ncol(data)
n;p
source("../R/matlab.R")
r <- m.repmat(colSums(data)/n, n, 1)
m.size(r)
A <- matrix(c(1,2,3,4), ncol = 2, byrow = F)
A
r <- m.repmat(A, 2, 3)
r
# column sums
cs <- colSums(data) / n        # numeric vector, no matrix
# convert to matrix 1x17, like in Matlab
mcs <- matrix(cs, nrow = 1)
dim(mcs)
source("../R/matlab.R")
# create a new matrix 384x17
r <- m.repmat(mcs, n, 1)
dim(r)
source("../R/matlab.R")
# column sums
cs <- colSums(data) / n        # numeric vector, no matrix
# convert to matrix 1x17, like in Matlab
mcs <- matrix(cs, nrow = 1)
datac <- data - m.repmat(mcs, n, 1)  # center the data
dim(datac)
source("../R/matlab.R")
# find the covariance matrix_type
covm <- cov(datac)
eig <- m.eig(covm)
eigvec <- eig$vectors
eigval <- eig$values
eigvald <- matrix(diag(eigval))  # Extract the diagonal elements
# Order in descending order
eigvale <- m.flipud(eigvald)
eigvece <- eigvec[, p:1]
eigvald
eigvale
# Build scree plot
plot(1:length(eigvale), eigvale,
type = "l",
main = "Scree Plot",
xlab = "Eigenvalue Index",
ylab = "Eigenvalue")
points(1:length(eigvale), eigvale)
pervar = 100*apply(eigvale, 2, cumsum)/sum(eigvale)
# First get the expected sizes of the eigenvalues.
g <- matrix(0, nrow= 1, ncol = p)
for (k in 1:p) {
for (i in k:p) {
g[k] <- g[k] + 1 /i
}
}
g <- g / p
propvar <- eigvale / sum(eigvale)
g[1:4]
propvar[1:4]
# Now for the size of the variance.
avgeig = mean(eigvale);
# Find the length of ind:
ind <- which(eigvale > avgeig)
length(ind)
# So, using 3, we will reduce the dimensionality.
P = eigvece[,1:3]
Xp = datac %*% P
library(lattice)
cloud(Xp[,1]~Xp[,2] * Xp[,3])
library("plot3D")
scatter3D(Xp[,1], Xp[,2], Xp[,3],
col = "blue",
pch = 19,
cex = 0.5,
bty = "b2",
xlab = "PC1",
ylab = "PC2",
zlab = "PC3",
theta = 30,       # 3D viewing direction: azimuth
phi = 15,           # co-latitude
ticktype = "detailed"
)
install.packages("plot3D")
library("plot3D")
scatter3D(Xp[,1], Xp[,2], Xp[,3],
col = "blue",
pch = 19,
cex = 0.5,
bty = "b2",
xlab = "PC1",
ylab = "PC2",
zlab = "PC3",
theta = 30,       # 3D viewing direction: azimuth
phi = 15,           # co-latitude
ticktype = "detailed"
)
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
library(R.matlab)
source("../R/matlab.R")
# read the Matlab array
lsiex.mat <- readMat("../data/lsiex.mat", fixNames = TRUE)
names(lsiex.mat)
termdoc <- lsiex.mat$termdoc
X <- lsiex.mat$X
# Loads up variables: X, termdoc, docs and words.
# Convert the matrix to one that has columns
# with a magnitude of 1.
n <- m.size(termdoc)[1]
p <- m.size(termdoc)[2]
no <- m.zeros(1, p)
for (i in 1:p) {
no[,i] = norm(matrix(X[, i]), 'f')   # Frobenius norm
termdoc[, i] <- X[, i] / no[,i]
}
no
X
termdoc
q1 <- t(matrix(c(1, 0, 1, 0, 0, 0), nrow=1))
dim(q1)
# Find the cosine of the angle between
# columns of termdoc and query.
# Note that the magnitude of q1 is not 1.
m1 <- norm(q1, 'f')
cosq1a <- t(q1) %*% termdoc / m1
# Note that the magnitude of q2 is 1.
cosq2a = t(q2) %*% termdoc
q2 <- t(matrix(c(1, 0, 0, 0, 0, 0), nrow=1))
dim(q2)
# Find the cosine of the angle between
# columns of termdoc and query.
# Note that the magnitude of q1 is not 1.
m1 <- norm(q1, 'f')
cosq1a <- t(q1) %*% termdoc / m1
# Note that the magnitude of q2 is 1.
cosq2a = t(q2) %*% termdoc
cosq1a
cosq2a
svd(termdoc)
source("../R/matlab.R")
svd_all <- m.svd(termdoc)
u <- svd_all$u
d <- svd_all$d
v <- svd_all$v
# Project the query vectors.
q1t <- t(u[, 1:3]) %*% q1
q2t <- t(u[, 1:3]) %*% q2
# Now find the cosine of the angle between the query
# vector and the columns of the reduced rank matrix,
# scaled by D.
cosq1b = matrix()
cosq2b = matrix()
for (i in 1:5) {
tv <- matrix(t(v[i, 1:3]), ncol=1)
sj <- d[1:3, 1:3] %*% tv
m3 <- norm(sj, 'f')
cosq1b[i] <- t(sj) %*% q1t / (m3 * m1)
cosq2b[i] <- t(sj) %*% q2t / (m3)
}
cosq1b
cosq2b
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
library(R.matlab)
library(Hmisc)
library(R.matlab)
source("../R/matlab.R")
# read the Matlab array
stockreturns.mat <- readMat("../data/stockreturns.mat", fixNames = TRUE)
names(stockreturns.mat)
stocks <- stockreturns.mat$stocks
head(stocks)
title = "Varimax rotation"
fac.anal <- factanal(stocks, factors = 3, rotation = "varimax")
Lam <- fac.anal$loadings
plot(Lam[,1], Lam[, 2], xlim = c(-1,1), ylim=c(-1,1), main = title)
abline(h=0, v=0)
text(Lam[, 1], Lam[, 2], labels = 1:10, cex = 0.7, pos = 3)
plot(Lam[,1], Lam[, 3], xlim = c(-1,1), ylim=c(-1,1), main = title)
abline(h=0, v=0)
text(Lam[, 1], Lam[, 3], labels = 1:10, cex = 0.7, pos=3)
title = "No rotation"
lam.psi <- factanal(stocks, factors = 3)
Lam <- fac.anal$loadings
plot(Lam[,1], Lam[, 2], xlim = c(-1,1), ylim=c(-1,1), main = title)
abline(h=0, v=0)
text(Lam[, 1], Lam[, 2], labels = 1:10, cex = 0.7, pos = 3)
plot(Lam[,1], Lam[, 3], xlim = c(-1,1), ylim=c(-1,1), main = title)
abline(h=0, v=0)
text(Lam[, 1], Lam[, 3], labels = 1:10, cex = 0.7, pos=3)
title = "Promax rotation"
lam.psi <- factanal(stocks, factors = 3, rotation = "promax")
Lam <- fac.anal$loadings
plot(Lam[,1], Lam[, 2], xlim = c(-1,1), ylim=c(-1,1), main = title)
abline(h=0, v=0)
text(Lam[, 1], Lam[, 2], labels = 1:10, cex = 0.7, pos = 3)
plot(Lam[,1], Lam[, 3], xlim = c(-1,1), ylim=c(-1,1), main = title)
abline(h=0, v=0)
text(Lam[, 1], Lam[, 3], labels = 1:10, cex = 0.7, pos=3)
library("plot3D")
n <- 500
theta <- runif(n =  n, min = 0, max = 4*pi)
# Use in the equations for a helix￿
x <- cos(theta)
y <- sin(theta)
z <- 0.1 * (theta)
# Put into a data matrix
# X = [x(,),y(,),z(,)]
X <- matrix(c(x, y, z), 500, 3)
scatter3D(x, y, z,
col = "blue",
pch = 19,
cex = 0.5,
bty = "b2",
xlab = "x",
ylab = "y",
zlab = "z",
theta = -45,       # 3D viewing direction: azimuth
phi = 30,           # co-latitude
ticktype = "detailed"
)
# Set knitr options for knitting code into the report:
# - Don't print out code (echo)
# - Save results so that code blocks aren't re-run unless code changes (cache),
# _or_ a relevant earlier code block changed (autodep), but don't re-run if the
# only thing that changed was the comments (cache.comments)
# - Don't clutter R output with messages or warnings (message, warning)
# This _will_ leave error messages showing up in the knitted report
knitr::opts_chunk$set(echo = TRUE,
cache = TRUE,
autodep = TRUE,
cache.comments = FALSE,
message = FALSE,
warning = FALSE,
error = TRUE,
comment = NA)
library(ggplot2)
f <- function (beta) beta**4 - 3 * beta**3 + 2     # build the function
beta <- seq(-2, 4, length.out = 100)               # points for plotting
qplot(beta,
f(beta),
xlab = expression(beta),
ylab = expression(f(beta)),
geom = 'line') +
geom_vline(xintercept = 9/4, col = 'red')
# Set the initial guess and other parameters
beta_old <- 0; beta_new <- 4; gamma <- 0.001; precision <- 0.00001
# Derivative of the function f
f_prime <- function (beta) 4 * beta**3 - 9 * beta**2
# create dataframebet
dframe <- data.frame(beta = rep(beta, 2),
curves = c(f(beta), f_prime(beta)),
type = rep(c("f", "f'"), each = 100))
# plot
p <- ggplot(data = dframe, aes(x = beta, y = curves, colour = type)) +
geom_line() +
geom_segment(aes(x = beta_new,
y = f(beta_new),
xend = beta_new,
yend = f_prime(beta_new),
colour = 'orange'), show.legend = TRUE) +
xlab(expression(beta)) + ylab('y') +
theme(legend.position = c(.2, .85),
legend.background = element_rect(fill = 'gray')) +
scale_colour_manual(name = 'Curves and Segments',
labels = c(
expression(f(beta)),
expression(paste(frac(df(beta), paste('d', beta)), sep = "")),
expression(bar(paste(f(beta[r]), paste(f, "'", (beta[r]), sep = ""))))
),
values = c('#FF033E', '#318CE7', '#FFBF00'),
guide = guide_legend(direction = "horizontal",
title.position = "top",
label.position = "right",
label.theme = element_text(angle = 0, size = 10))
)
# Perform Gradient Descent
i <- 0 # Counter for number of iterations
p <- p + geom_segment(x = beta_new,
y = f(beta_new),
xend = beta_new,
yend = f_prime(beta_new),
colour = '#FFA812')
while (abs(beta_new - beta_old) > precision) {
beta_old <- beta_new
beta_new <- beta_old - gamma * f_prime(beta_old)
p <- p + geom_segment(x = beta_new,
y = f(beta_new),
xend = beta_new,
yend = f_prime(beta_new),
colour = '#FFA812')
i <- i + 1
}
# Print results
p; i; beta_new
