points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
fit <- lm(P[,2]~P[,1])
abline(fit, col="green")
plot(X[, 1], X[, 2],
xlim = c(-8, 8),
ylim = c(-8, 8),
pch = 22,
cex = 1.55
)
abline(h=0, v=0)             # lines at (0, 0)
points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
fit <- lm(P[,2]~P[,1])
abline(fit, col="green")
plot(X[, 1], X[, 2],
xlim = c(-8, 8),
ylim = c(-8, 8),
pch = 23,
cex = 1.55
)
abline(h=0, v=0)             # lines at (0, 0)
points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
fit <- lm(P[,2]~P[,1])
abline(fit, col="green")
plot(X[, 1], X[, 2],
xlim = c(-8, 8),
ylim = c(-8, 8),
pch = 24,
cex = 1.55
)
abline(h=0, v=0)             # lines at (0, 0)
points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
fit <- lm(P[,2]~P[,1])
abline(fit, col="green")
plot(X[, 1], X[, 2],
xlim = c(-8, 8),
ylim = c(-8, 8),
pch = 25,
cex = 1.55
)
abline(h=0, v=0)             # lines at (0, 0)
points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
fit <- lm(P[,2]~P[,1])
abline(fit, col="green")
plot(X[, 1], X[, 2],
xlim = c(-8, 8),
ylim = c(-8, 8),
pch = 26,
cex = 1.55
)
abline(h=0, v=0)             # lines at (0, 0)
points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
fit <- lm(P[,2]~P[,1])
abline(fit, col="green")
plot(X[, 1], X[, 2],
xlim = c(-8, 8),
ylim = c(-8, 8),
pch = 27,
cex = 1.55
)
abline(h=0, v=0)             # lines at (0, 0)
points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
fit <- lm(P[,2]~P[,1])
abline(fit, col="green")
plot(X[, 1], X[, 2],
xlim = c(-8, 8),
ylim = c(-8, 8),
pch = 28,
cex = 1.55
)
abline(h=0, v=0)             # lines at (0, 0)
points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
fit <- lm(P[,2]~P[,1])
abline(fit, col="green")
plot(X[, 1], X[, 2],
xlim = c(-8, 8),
ylim = c(-8, 8),
pch = 31,
cex = 1.55
)
abline(h=0, v=0)             # lines at (0, 0)
points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
fit <- lm(P[,2]~P[,1])
abline(fit, col="green")
plot(X[, 1], X[, 2],
xlim = c(-8, 8),
ylim = c(-8, 8),
pch = 21,
cex = 1.55
)
abline(h=0, v=0)             # lines at (0, 0)
points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
fit <- lm(P[,2]~P[,1])
abline(fit, col="green")
plot(X[, 1], X[, 2],
xlim = c(-8, 8),
ylim = c(-8, 8),
pch = 22,
cex = 1.55
)
abline(h=0, v=0)             # lines at (0, 0)
points(Xpx[1], 0, pch=11)    # plot point projections on x-axis
points(Xpx[2], 0, pch=11)    # plot point projections on x-axis
fit <- lm(P[,2]~P[,1])
abline(fit, col="green")
fEigval <- OctaveFunction("
function [eigval] = scree()
load yeast
[n,p] = size(data);
% Center the data.
datac = data - repmat(sum(data)/n,n,1);
% Find the covariance matrix.
covm = cov(datac);
[eigvec,eigval] = eig(covm);
eigval = diag(eigval); % Extract the diagonal elements
% Order in descending order
eigval = flipud(eigval);
eigvec = eigvec(:,p:-1:1);
end  ")
fEigval <- OctaveFunction("
function [eigval] = scree()
load yeast
[n,p] = size(data);
% Center the data.
datac = data - repmat(sum(data)/n,n,1);
% Find the covariance matrix.
covm = cov(datac);
[eigvec,eigval] = eig(covm);
eigval = diag(eigval); % Extract the diagonal elements
% Order in descending order
eigval = flipud(eigval);
eigvec = eigvec(:,p:-1:1);
end  ")
eigvale <- fEigval()
# Build scree plot
plot(1:length(eigvale), eigvale,
type = "l",
main = "Scree Plot",
xlab = "Eigenvalue Index",
ylab = "Eigenvalue")
points(1:length(eigvale), eigvale)
pca_yeast <- OctaveFunction("
function [eigval, pervar, g, propvar, Xp] = scree()
load yeast
[n,p] = size(data);
% Center the data.
datac = data - repmat(sum(data)/n,n,1);
% Find the covariance matrix.
covm = cov(datac);
[eigvec,eigval] = eig(covm);
eigval = diag(eigval); % Extract the diagonal elements
% Order in descending order
eigval = flipud(eigval);
eigvec = eigvec(:,p:-1:1);
% Now for the percentage of variance explained.
pervar = 100*cumsum(eigval)/sum(eigval);
% First get the expected sizes of the eigenvalues.
g = zeros(1,p);
for k = 1:p
for i = k:p
g(k) = g(k) + 1/i;
end
end
g = g/p;
propvar = eigval/sum(eigval);
% Now for the size of the variance.
avgeig = mean(eigval);
% Find the length of ind:
ind = find(eigval > avgeig);
length(ind)
% So, using 3, we will reduce the dimensionality.
P = eigvec(:,1:3);
Xp = datac*P;
%% figure,plot3(Xp(:,1),Xp(:,2),Xp(:,3),'k*')
%% xlabel('PC 1'),ylabel('PC 2'),zlabel('PC 3')
%% grid on, axis tight
end  ")
f_pca_yeast <- OctaveFunction("
function [eigval, pervar, g, propvar, Xp] = scree()
load yeast
[n,p] = size(data);
% Center the data.
datac = data - repmat(sum(data)/n,n,1);
% Find the covariance matrix.
covm = cov(datac);
[eigvec,eigval] = eig(covm);
eigval = diag(eigval); % Extract the diagonal elements
% Order in descending order
eigval = flipud(eigval);
eigvec = eigvec(:,p:-1:1);
% Now for the percentage of variance explained.
pervar = 100*cumsum(eigval)/sum(eigval);
% First get the expected sizes of the eigenvalues.
g = zeros(1,p);
for k = 1:p
for i = k:p
g(k) = g(k) + 1/i;
end
end
g = g/p;
propvar = eigval/sum(eigval);
% Now for the size of the variance.
avgeig = mean(eigval);
% Find the length of ind:
ind = find(eigval > avgeig);
length(ind)
% So, using 3, we will reduce the dimensionality.
P = eigvec(:,1:3);
Xp = datac*P;
%% figure,plot3(Xp(:,1),Xp(:,2),Xp(:,3),'k*')
%% xlabel('PC 1'),ylabel('PC 2'),zlabel('PC 3')
%% grid on, axis tight
end  ")
pca_yeast <- f_pca_yeast()
f_pca_yeast <- OctaveFunction("
function [eigval, pervar, g, propvar, Xp] = scree()
load yeast
[n,p] = size(data);
% Center the data.
datac = data - repmat(sum(data)/n,n,1);
% Find the covariance matrix.
covm = cov(datac);
[eigvec,eigval] = eig(covm);
eigval = diag(eigval); % Extract the diagonal elements
% Order in descending order
eigval = flipud(eigval);
eigvec = eigvec(:,p:-1:1);
% Now for the percentage of variance explained.
pervar = 100*cumsum(eigval)/sum(eigval);
% First get the expected sizes of the eigenvalues.
g = zeros(1,p);
for k = 1:p
for i = k:p
g(k) = g(k) + 1/i;
end
end
g = g/p;
propvar = eigval/sum(eigval);
% Now for the size of the variance.
avgeig = mean(eigval);
% Find the length of ind:
ind = find(eigval > avgeig);
length(ind);
% So, using 3, we will reduce the dimensionality.
P = eigvec(:,1:3);
Xp = datac*P;
%% figure,plot3(Xp(:,1),Xp(:,2),Xp(:,3),'k*')
%% xlabel('PC 1'),ylabel('PC 2'),zlabel('PC 3')
%% grid on, axis tight
end  ")
pca_yeast <- f_pca_yeast()
pca_yeast <- f_pca_yeast()
eigvale <- pca_yeast$eigval
# Build scree plot
plot(1:length(eigvale), eigvale,
type = "l",
main = "Scree Plot",
xlab = "Eigenvalue Index",
ylab = "Eigenvalue")
points(1:length(eigvale), eigvale)
pca_yeast <- f_pca_yeast()
eigvale <- pca_yeast$eigval
Xp <- pca_yeast$Xp
```{r fig.asp=1}
library("plot3D")
scatter3D(Xp[,1], Xp[,2], Xp[,3],
col = "blue",
pch = 19,
cex = 0.5,
bty = "b2",
xlab = "PC1",
ylab = "PC2",
zlab = "PC3",
theta = 30,       # 3D viewing direction: azimuth
phi = 15,           # co-latitude
ticktype = "detailed"
)
library(RcppOctave)
.CallOctave("version")
fLsiex <- OctaveFunction("
function [u, v, d, cosq1a, cosq2a, cosq1b, cosq2b] = lsiex()
load lsiex
% Loads up variables: X, termdoc, docs and words.
% Convert the matrix to one that has columns
% with a magnitude of 1.
[n,p] = size(termdoc);
for i = 1:p
termdoc(:,i) = X(:,i)/norm(X(:,i));
end
q1 = [1 0 1 0 0 0]';
q2 = [1 0 0 0 0 0]';
% Find the cosine of the angle between
% columns of termdoc and query.
% Note that the magnitude of q1 is not 1.
m1 = norm(q1);
cosq1a = q1'*termdoc/m1;
% Note that the magnitude of q2 is 1.
cosq2a = q2'*termdoc;
% Find the singular value decomposition.
[u,d,v] = svd(termdoc);
% Project the query vectors.
q1t = u(:,1:3)'*q1;
q2t = u(:,1:3)'*q2;
% Now find the cosine of the angle between the query
% vector and the columns of the reduced rank matrix,
% scaled by D.
for i = 1:5
sj = d(1:3,1:3)*v(i,1:3)';
m3 = norm(sj);
cosq1b(i) = sj'*q1t/(m3*m1);
cosq2b(i) = sj'*q2t/(m3);
end
end                         ")
f_lsiex <- OctaveFunction("
function [u, v, d, cosq1a, cosq2a, cosq1b, cosq2b] = lsiex()
load lsiex
% Loads up variables: X, termdoc, docs and words.
% Convert the matrix to one that has columns
% with a magnitude of 1.
[n,p] = size(termdoc);
for i = 1:p
termdoc(:,i) = X(:,i)/norm(X(:,i));
end
q1 = [1 0 1 0 0 0]';
q2 = [1 0 0 0 0 0]';
% Find the cosine of the angle between
% columns of termdoc and query.
% Note that the magnitude of q1 is not 1.
m1 = norm(q1);
cosq1a = q1'*termdoc/m1;
% Note that the magnitude of q2 is 1.
cosq2a = q2'*termdoc;
% Find the singular value decomposition.
[u,d,v] = svd(termdoc);
% Project the query vectors.
q1t = u(:,1:3)'*q1;
q2t = u(:,1:3)'*q2;
% Now find the cosine of the angle between the query
% vector and the columns of the reduced rank matrix,
% scaled by D.
for i = 1:5
sj = d(1:3,1:3)*v(i,1:3)';
m3 = norm(sj);
cosq1b(i) = sj'*q1t/(m3*m1);
cosq2b(i) = sj'*q2t/(m3);
end
end                         ")
lsiex <- f_lsiex()
lsiex <- f_lsiex()
u <- lsiex$u
v <- lsiex$v
d <- lsiez$d
lsiex <- f_lsiex()
u <- lsiex$u
v <- lsiex$v
d <- lsiex$d
u; v; d
plot(u,v,d)
plot(u,v)
plot(u,v)
plot(u,d)
plot(u,d)
plot(u)
plot(u)
point(v)
plot(u)
points(v)
plot(u)
points(v, col = "red")
plot(u, col = "blue")
points(v, col = "red")
plot(u, col = "blue")
points(v, col = "red")
pointd(d, col = "cyan")
plot(u, col = "blue")
points(v, col = "red")
points(d, col = "cyan")
plot(u, col = "blue")
points(v, col = "red")
points(d, col = "orange")
plot(u, col = "blue")
points(v, col = "red")
points(d, col = "black")
lsiex <- f_lsiex()
u <- lsiex$u
v <- lsiex$v
d <- lsiex$d
cosq1a <- lsiex$cosq1a
cosq2a <- lsiex$cosq2a
u; v; d
plot(cosq1a)
plot(cosq1a, cosq2a)
cosq1a
plot(cosq1a, cosq2a)
cosq1a
cosq2a
plot(cosq1a, cosq2a)
lsiex <- f_lsiex()
u <- lsiex$u
v <- lsiex$v
d <- lsiex$d
cosq1a <- lsiex$cosq1a
cosq2a <- lsiex$cosq2a
cosq1b <- lsiex$cosq1b
cosq2b <- lsiex$cosq2b
u; v; d
cosq1b
cosq2b
plot(cosq1b, cosq2b)
library(RcppOctave)
.CallOctave("version")
f_stocks <- OctaveFunction("
function [x] = stocks
load stockreturns
% Loads up a variable called stocks.
% Perform factor analysis:3 factors,default rotation.
[LamVrot,PsiVrot] = factoran(stocks,3);
end
")
f_stocks <- OctaveFunction("
function [x] = stocks()
load stockreturns
% Loads up a variable called stocks.
% Perform factor analysis:3 factors,default rotation.
[LamVrot,PsiVrot] = factoran(stocks,3);
end
")
stocks <- f_stocks()
f_stocks <- OctaveFunction("
function [x] = stocks()
load stockreturns
% Loads up a variable called stocks.
% Perform factor analysis:3 factors,default rotation.
% [LamVrot,PsiVrot] = factoran(stocks,3);
end
")
stocks <- f_stocks()
f_stocks <- OctaveFunction("
function [x] = stocks()
load stockreturns
% Loads up a variable called stocks.
% Perform factor analysis:3 factors,default rotation.
% [LamVrot,PsiVrot] = factoran(stocks,3);
x = 1;
end
")
stocks <- f_stocks()
f_stocks <- OctaveFunction("
function [x] = stocks()
load stockreturns
% Loads up a variable called stocks.
% Perform factor analysis:3 factors,default rotation.
LamVrot,PsiVrot] = factoran(stocks,3);
x = 1;
end
")
f_stocks <- OctaveFunction("
function [x] = stocks()
load stockreturns
% Loads up a variable called stocks.
% Perform factor analysis:3 factors,default rotation.
[LamVrot,PsiVrot] = factoran(stocks,3);
x = 1;
end
")
stocks <- f_stocks()
library(RcppOctave)
.CallOctave("version")
f_stocks <- OctaveFunction("
function [x] = stocks()
load stockreturns
% Loads up a variable called stocks.
% Perform factor analysis:3 factors,default rotation.
[LamVrot,PsiVrot] = factoran(stocks,3);
x = 1;
end
")
stocks <- f_stocks()
f_stocks <- OctaveFunction("
function [x] = stocks()
pkg load statistics
load stockreturns
% Loads up a variable called stocks.
% Perform factor analysis:3 factors,default rotation.
[LamVrot,PsiVrot] = factoran(stocks,3);
x = 1;
end
")
stocks <- f_stocks()
stocks <- f_stocks()
library(RcppOctave)
.CallOctave("version")
f_stocks <- OctaveFunction("
function [x] = stocks()
pkg load statistics
load stockreturns
% Loads up a variable called stocks.
% Perform factor analysis:3 factors,default rotation.
[LamVrot,PsiVrot] = factoran(stocks,3);
x = 1;
end
")
stocks <- f_stocks()
