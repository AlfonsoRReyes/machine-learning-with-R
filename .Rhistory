print(dim(xtrace))
print(x) # x converges to 2.0
xs <- seq(0, 4,len=20) # create some values
# define the function we want to optimize
f <-  function(x) {
1.2 * (x-2)^2 + 3.2
}
# plot the function
plot(xs, f (xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x-2)^2 +3.2))
# calculate the gradient df/dx
grad <- function(x){
1.2*2*(x-2)
}
# df/dx = 2.4(x-2), if x = 2 then 2.4(2-2) = 0
# The actual solution we will approximate with gradeint descent
# is  x = 2 as depicted in the plot below
lines (c(2,2), c(3,8), col="green", lty=2)
text (2.1,7, "Closed-form solution", col="red", pos=4)
# gradient descent implementation
x <- 0.1       # initialize the first guess for x-value
xtrace <- x    # store x -values for graphing purposes (initial)
ftrace <- f(x) # store y-values (function eval at x) for graphing purposes (initial)
stepFactor <- 0.6 # learning rate 'alpha'
for (step in 1:100) {
x <- x - stepFactor * grad(x) # gradient descent update
xtrace <- c(xtrace, x)      # update for graph
ftrace <- c(ftrace, f(x))   # update for graph
}
lines (xtrace, ftrace, type="b", col="blue")
text (0.5, 6, "Gradient Descent", col="blue", pos= 4)
# print final value of x
print(length(xtrace))
print(x) # x converges to 2.0
xs <- seq(0, 4,len=20) # create some values
# define the function we want to optimize
f <-  function(x) {
1.2 * (x-2)^2 + 3.2
}
# plot the function
plot(xs, f (xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x-2)^2 +3.2))
# calculate the gradient df/dx
grad <- function(x){
1.2*2*(x-2)
}
# df/dx = 2.4(x-2), if x = 2 then 2.4(2-2) = 0
# The actual solution we will approximate with gradeint descent
# is  x = 2 as depicted in the plot below
lines (c(2,2), c(3,8), col="green", lty=2)
text (2.1,7, "Closed-form solution", col="red", pos=4)
# gradient descent implementation
x <- 0.1       # initialize the first guess for x-value
xtrace <- x    # store x -values for graphing purposes (initial)
ftrace <- f(x) # store y-values (function eval at x) for graphing purposes (initial)
stepFactor <- 0.6 # learning rate 'alpha'
for (step in 1:100) {
x <- x - stepFactor * grad(x) # gradient descent update
xtrace <- c(xtrace, x)      # update for graph
ftrace <- c(ftrace, f(x))   # update for graph
}
lines (xtrace, ftrace, type="b", col="blue")
text (0.5, 6, "Gradient Descent", col="blue", pos= 4)
# print final value of x
print(length(xtrace))
print(length(ftrace))
print(x) # x converges to 2.0
f <-function(x) {
1.2 * (x−2)^2 + 3.2
}
grad <− function(x) {
1.2 * 2 * (x−2)
}
secondGrad <− function(x) {
2.4
}
xs <− seq(0,4,len=20)
plot (xs , f (xs ), type=”l”,xlab=”x”,ylab=expression(1.2(x−2)ˆ2 +3.2))
xs <− seq(0,4,len=20)
plot (xs , f(xs), type=”l”,xlab=”x”,ylab=expression(1.2(x−2)^2 +3.2))
xs <− seq(0,4,len=20)
plot (xs , f(xs),
type = ”l”,
f <- function(x) {
1.2 * (x−2)^2 + 3.2
}
grad <− function(x) {
1.2 * 2 * (x−2)
}
secondGrad <− function(x) {
2.4
}
xs <− seq(0,4,len=20)
plot(xs, f(xs),
type = ”l”,
xs <− seq(0,4,len=20)
plot(xs, f(xs),
type = ”l”,
xs <− seq(0,4, len=20)
plot(xs, f(xs),
type = ”l”,
plot(xs, f(xs))
plot(xs, f(xs), type = "l")
plot(xs, f(xs), type = "l", xlab = "x")
plot(xs, f(xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
xs <− seq(0,4, len=20)
plot(xs, f(xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x−2)^2 +3.2))
### df/dx = 2.4(x−2)
### df/dx = 0 −−−> 0 = 2.4x − 4.8 −−−> x = 2
lines (c (2,2), c (3,8), col =”red”,lty=2)
xs <− seq(0,4, len=20)
plot(xs, f(xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x−2)^2 +3.2))
### df/dx = 2.4(x−2)
### df/dx = 0 −−−> 0 = 2.4x − 4.8 −−−> x = 2
lines (c (2,2), c (3,8), col = "red"", lty =2)
text (2.1,7, "Closed−form solution", col="red", pos=4)
xs <− seq(0,4, len=20)
plot(xs, f(xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x−2)^2 +3.2))
### df/dx = 2.4(x−2)
### df/dx = 0 −−−> 0 = 2.4x − 4.8 −−−> x = 2
lines (c (2,2), c (3,8), col = "red", lty =2)
text (2.1,7, "Closed−form solution", col="red", pos=4)
### gradient descent
x <− 0.1
xtrace <− x
ftrace <− f(x)
stepFactor <− 0.6 ### try larger and smaller values (0.8 and 0.01)
for (step in 1:100) {
x <− x − stepFactor * grad(x)
xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}lines ( xtrace , ftrace , type=”b”,col=”blue”)
xs <− seq(0,4, len=20)
plot(xs, f(xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x−2)^2 +3.2))
### df/dx = 2.4(x−2)
### df/dx = 0 −−−> 0 = 2.4x − 4.8 −−−> x = 2
lines (c (2,2), c (3,8), col = "red", lty =2)
text (2.1,7, "Closed−form solution", col="red", pos=4)
### gradient descent
x <− 0.1
xtrace <− x
ftrace <− f(x)
stepFactor <− 0.6 ### try larger and smaller values (0.8 and 0.01)
for (step in 1:100) {
x <− x − stepFactor * grad(x)
xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}
lines ( xtrace , ftrace , type="b", col="blue")
text (0.5,6, "Gradient Descent",col=”blue”,pos=4)
xs <− seq(0,4, len=20)
plot(xs, f(xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x−2)^2 +3.2))
### df/dx = 2.4(x−2)
### df/dx = 0 −−−> 0 = 2.4x − 4.8 −−−> x = 2
lines (c (2,2), c (3,8), col = "red", lty =2)
text (2.1,7, "Closed−form solution", col="red", pos=4)
### gradient descent
x <− 0.1
xtrace <− x
ftrace <− f(x)
stepFactor <− 0.6 ### try larger and smaller values (0.8 and 0.01)
for (step in 1:100) {
x <− x − stepFactor * grad(x)
xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}
lines ( xtrace , ftrace , type="b", col="blue")
text (0.5,6, "Gradient Descent", col = "blue", pos=4)
source("./R/gradientDescents.R")
x <− 0.1
result <− steepest(x, f, grad , stepsize =0.6, nIterations =100, xtracep=TRUE, ftracep=TRUE)
plot (xs, f(xs ), type="l",xlab="x", ylab=expression(1.2(x−2)^2 +3.2))
lines ( result $xtrace , result $ ftrace , type="b",col="blue")
text (0.5,6, "Gradient Descent with steepest ()", col ="blue",pos=4)
source("./R/gradientDescents.R")
x <− 0.1
result <− steepest(x, f,
grad,
stepsize = 0.6,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot (xs, f(xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace , type ="b", col ="blue")
text (0.5,6, "Gradient Descent with steepest ()", col ="blue",pos=4)
plot(xs, f(xs ), type= "l", xlab="x", ylab=expression(1.2(x−2)^2 +3.2))
x <− 0.1
xtrace <− x
ftrace <− f(x)
for (step in 1:100) {
x <− x − grad(x)/secondGrad(x)
xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}
lines(xtrace, ftrace , type="b",col="blue")
text (0.5,6, "Newton's Gradient Descent",col="blue",pos=4)
source("./R/gradientDescents.R")
x <− 0.1
result <− scg(x, f,
grad ,
nIterations =100,
xtracep=TRUE,
ftracep=TRUE)
plot (xs , f (xs ), type="l",xlab="x",ylab=expression(1.2(x−2)^2 +3.2))
lines (result$xtrace, result$ftrace , type ="b", col="blue")
text (0.5,6, "Gradient Descent with scg ()", col ="blue",pos=4)
source("./R/gradientDescents.R")
x <− 0.1
result <− scg(x, f,
grad ,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot(xs, f (xs), type = "l", xlab = "x",ylab=expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace, type = "b", col = "blue")
text(0.5, 6, "Gradient Descent with scg ()", col = "blue", pos = 4)
plot(xs, f(xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
x <− 0.1
xtrace <− x
ftrace <− f(x)
for (step in 1:100) {
x <− x − grad(x) / secondGrad(x)
xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}
lines(xtrace, ftrace, type = "b", col = "blue")
text (0.5, 6, "Newton's Gradient Descent", col = "blue", pos = 4)
f <- function(x) {
1.2 * (x−2)^2 + 3.2
}
grad <− function(x) {
1.2 * 2 * (x−2)
}
secondGrad <− function(x) {
2.4
}
xs <− seq(0,4, len = 20)
plot(xs, f(xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x−2)^2 +3.2))
### df/dx = 2.4(x−2)
### df/dx = 0 −−−> 0 = 2.4x − 4.8 −−−> x = 2
lines (c(2,2), c(3,8), col = "red", lty = 2)
text (2.1, 7, "Closed−form solution", col = "red", pos = 4)
### gradient descent
x <− 0.1
xtrace <− x
ftrace <− f(x)
stepFactor <− 0.6 ### try larger and smaller values (0.8 and 0.01)
for (step in 1:100) {
x <− x − stepFactor * grad(x)
xtrace <− c(xtrace, x)
ftrace <− c(ftrace, f(x))
}
lines( xtrace , ftrace , type="b", col = "blue")
text(0.5, 6, "Gradient Descent", col = "blue", pos = 4)
source("./R/gradientDescents.R")
x <− 0.1
result <− steepest(x, f,
grad,
stepsize = 0.6,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot(xs, f(xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace , type = "b", col = "blue")
text (0.5, 6, "Gradient Descent with steepest ()", col = "blue", pos = 4)
source("./R/gradientDescents.R")
x <− 0.1
result <− scg(x, f,
grad,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot(xs, f (xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace, type = "b", col = "blue")
text(0.5, 6, "Gradient Descent with scg ()", col = "blue", pos = 4)
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
f <- function(x) {
1.2 * (x−2)^2 + 3.2
}
grad <− function(x) {
1.2 * 2 * (x−2)
}
secondGrad <− function(x) {
2.4
}
xs <− seq(0,4, len = 20)
plot(xs, f(xs),
type = "l",
xlab = "x",
ylab = expression(1.2(x−2)^2 +3.2))
### df/dx = 2.4(x−2)
### df/dx = 0 −−−> 0 = 2.4x − 4.8 −−−> x = 2
lines (c(2,2), c(3,8), col = "red", lty = 2)
text (2.1, 7, "Closed−form solution", col = "red", pos = 4)
### gradient descent
x <− 0.1
xtrace <− x
ftrace <− f(x)
stepFactor <− 0.6 ### try larger and smaller values (0.8 and 0.01)
for (step in 1:100) {
x <− x − stepFactor * grad(x)
xtrace <− c(xtrace, x)
ftrace <− c(ftrace, f(x))
}
lines( xtrace , ftrace , type="b", col = "blue")
text(0.5, 6, "Gradient Descent", col = "blue", pos = 4)
source("./R/gradientDescents.R")
x <− 0.1
result <− steepest(x, f,
grad,
stepsize = 0.6,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot(xs, f(xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace , type = "b", col = "blue")
text(0.5, 6, "Gradient Descent with steepest ()", col = "blue", pos = 4)
plot(xs, f(xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
x <− 0.1
xtrace <− x
ftrace <− f(x)
for (step in 1:100) {
x <− x − grad(x) / secondGrad(x)
xtrace <− c(xtrace,x)
ftrace <− c(ftrace,f(x))
}
lines(xtrace, ftrace, type = "b", col = "blue")
text(0.5, 6, "Newton's Gradient Descent", col = "blue", pos = 4)
source("./R/gradientDescents.R")
x <− 0.1
result <− scg(x, f,
grad,
nIterations = 100,
xtracep = TRUE,
ftracep = TRUE)
plot(xs, f (xs), type = "l", xlab = "x", ylab = expression(1.2(x−2)^2 +3.2))
lines(result$xtrace, result$ftrace, type = "b", col = "blue")
text(0.5, 6, "Gradient Descent with scg ()", col = "blue", pos = 4)
install.packages("RcppOctave")
install.packages("RcppOctave")
install.packages("RcppOctave", source)
install.packages("RcppOctave", type="source")
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
install.packages(c("digest", "dygraphs", "fields", "ggplot2", "git2r", "Hmisc", "htmlTable", "jsonlite", "nycflights13", "openssl", "pracma", "psych", "RcppArmadillo", "rmarkdown", "rsconnect", "RSQLite", "selectr", "shiny", "sp", "tidyr", "xml2", "zoo"))
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
fx <- cxxfunction(signature(x = "numeric"), 'NumericVector xx(x);
return wrap(std::accumulate(xx.begin(), xx.end(), 0.0));'
, plugin = "Rcpp"
fx <- cxxfunction(signature(x = "numeric"), 'NumericVector xx(x);return wrap(std::accumulate(xx.begin(), xx.end(), 0.0));', plugin = "Rcpp"
library(Rcpp)
library(inline)
fx <- cxxfunction(signature(x = "numeric"), 'NumericVector xx(x);return wrap(std::accumulate(xx.begin(), xx.end(), 0.0));', plugin = "Rcpp")
fx <- cxxfunction(signature(x = "numeric"), 'NumericVector xx(x); return wrap(std::accumulate(xx.begin(), xx.end(), 0.0));', plugin = "Rcpp")
library(Rcpp)
library(inline)
src <- '
Rcpp::NumericMatrix Am(A);
int nrows = Am.nrow();
for (int j = 1; j < nrows; j++) {
Am(j,_) = Am(j,_) + Am(j-1,_);
}
return Am;
'
fun <- cxxfunction(signature(A = "numeric"), body = src, plugin="Rcpp")
sessionInfo()
View(y)
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
x <- leukemia[, 1:38]   #: take only the first 38 columns
n <- nrow(x)      # number of rows
p <- ncol(x)      # number of columns
y <- matrix(0, n, p)
for (i in 1:n) {
sig <- sd(x[i, ])
mu <- mean(x[i, ])
y[i, ] <- (x[i, ] - mu) / sig
}
library(R.matlab)
# Set knitr options for knitting code into the report:
# - Don't print out code (echo)
# - Save results so that code blocks aren't re-run unless code changes (cache),
# _or_ a relevant earlier code block changed (autodep), but don't re-run if the
# only thing that changed was the comments (cache.comments)
# - Don't clutter R output with messages or warnings (message, warning)
# This _will_ leave error messages showing up in the knitted report
knitr::opts_chunk$set(echo = TRUE,
cache = TRUE,
autodep = TRUE,
cache.comments = FALSE,
message = FALSE,
warning = FALSE,
error = TRUE,
comment = NA)
library(RcppOctave)
.CallOctave("version")
.CallOctave("sqrt", 10)
.CallOctave("eye", 3)
.CallOctave("eye", 3, 2)
install.packages("RcppOctave")
